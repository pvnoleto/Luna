#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
üöÄ LUNA V3 - COM TIER 2 CORRIGIDO + PLANEJAMENTO AVAN√áADO + PROCESSAMENTO PARALELO
===================================================================================

‚ú® NOVIDADES DESTA VERS√ÉO:
1. ‚úÖ LIMITES CORRETOS: Tier 2 = 1000 RPM, 450K ITPM, 90K OTPM (OFICIAL!)
2. üß† SISTEMA DE PLANEJAMENTO AVAN√áADO: Planos detalhados antes de executar
3. üîÑ PROCESSAMENTO PARALELO AGRESSIVO: 15-20 tarefas simult√¢neas
4. üõ°Ô∏è ANTI-RATE LIMIT: Monitora e previne erros 429
5. üîß RECUPERA√á√ÉO INTELIGENTE: Prioriza corrigir erros
6. üõë HANDLER DE INTERRUP√á√ÉO: Ctrl+C tratado graciosamente

VALORES OFICIAIS DOS TIERS (Fonte: Alex Albert - Anthropic):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Tier   ‚îÇ RPM     ‚îÇ ITPM       ‚îÇ OTPM       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Tier 1 ‚îÇ 50      ‚îÇ 30,000     ‚îÇ 8,000      ‚îÇ
‚îÇ Tier 2 ‚îÇ 1,000   ‚îÇ 450,000    ‚îÇ 90,000     ‚îÇ  ‚Üê CORRIGIDO!
‚îÇ Tier 3 ‚îÇ 2,000   ‚îÇ 800,000    ‚îÇ 160,000    ‚îÇ  ‚Üê CORRIGIDO!
‚îÇ Tier 4 ‚îÇ 4,000   ‚îÇ 2,000,000  ‚îÇ 400,000    ‚îÇ  ‚Üê CORRIGIDO!
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Vers√£o: 2025-10-17 (Tier 2 Completo + Planejamento + Paralelismo)
"""

import anthropic
from anthropic import BadRequestError, RateLimitError
import os
import sys
import subprocess
import json
from dotenv import load_dotenv
from datetime import datetime, timedelta
import getpass
from pathlib import Path
import time
import signal
import atexit
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional, Tuple
from concurrent.futures import ThreadPoolExecutor, as_completed
import threading

# Configura√ß√£o UTF-8
os.environ.setdefault("PYTHONUTF8", "1")
os.environ.setdefault("PYTHONIOENCODING", "utf-8")
os.environ["PYTHONUNBUFFERED"] = "1"

if sys.platform == 'win32':
    try:
        import codecs
        sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer, 'strict')
        sys.stderr = codecs.getwriter('utf-8')(sys.stderr.buffer, 'strict')
    except:
        pass

sys.stdout.reconfigure(line_buffering=True) if hasattr(sys.stdout, 'reconfigure') else None
sys.stderr.reconfigure(line_buffering=True) if hasattr(sys.stderr, 'reconfigure') else None


# ============================================================================
# CLASSES DE DADOS PARA PLANEJAMENTO
# ============================================================================

@dataclass
class Subtarefa:
    """Representa uma subtarefa execut√°vel"""
    id: str
    titulo: str
    descricao: str
    ferramentas: List[str]
    input_esperado: str
    output_esperado: str
    criterio_sucesso: str
    tokens_estimados: int
    tempo_estimado: str
    prioridade: str  # critica, importante, nice-to-have
    dependencias: List[str] = field(default_factory=list)
    concluida: bool = False
    resultado: Optional[str] = None


@dataclass
class Onda:
    """Representa uma onda de execu√ß√£o (subtarefas paralelas/sequenciais)"""
    numero: int
    descricao: str
    subtarefas: List[Subtarefa]
    pode_executar_paralelo: bool
    concluida: bool = False


@dataclass
class Plano:
    """Representa um plano completo de execu√ß√£o"""
    tarefa_original: str
    analise: Dict[str, Any]
    estrategia: Dict[str, Any]
    decomposicao: Dict[str, Any]
    ondas: List[Onda]
    criado_em: datetime
    executado_em: Optional[datetime] = None
    resultado: Optional[Dict[str, Any]] = None
    
    def salvar(self, caminho: str):
        """Salva o plano em arquivo JSON"""
        os.makedirs(os.path.dirname(caminho), exist_ok=True)
        
        with open(caminho, 'w', encoding='utf-8') as f:
            json.dump({
                'tarefa_original': self.tarefa_original,
                'analise': self.analise,
                'estrategia': self.estrategia,
                'decomposicao': self.decomposicao,
                'criado_em': self.criado_em.isoformat(),
                'executado_em': self.executado_em.isoformat() if self.executado_em else None,
                'resultado': self.resultado
            }, f, indent=2, ensure_ascii=False)


# ============================================================================
# HANDLER DE INTERRUP√á√ÉO
# ============================================================================

class InterruptHandler:
    """Gerencia interrup√ß√µes graciosamente"""
    
    def __init__(self, agente=None, sistema_ferramentas=None):
        self.agente = agente
        self.sistema_ferramentas = sistema_ferramentas
        self.interrompido = False
        self.limpeza_feita = False
        
        signal.signal(signal.SIGINT, self.handler_sigint)
        signal.signal(signal.SIGTERM, self.handler_sigterm)
        atexit.register(self.cleanup_final)
        
        print("‚úÖ Handler de interrup√ß√£o ativado (Ctrl+C ser√° tratado graciosamente)")
    
    def handler_sigint(self, signum, frame):
        """Handler para Ctrl+C"""
        if self.interrompido:
            print("\n\nüî¥ FOR√áANDO SA√çDA... (segunda interrup√ß√£o)")
            self.cleanup_forcado()
            sys.exit(1)
        
        self.interrompido = True
        print("\n\n‚ö†Ô∏è  INTERRUP√á√ÉO DETECTADA (Ctrl+C)")
        print("   Limpando recursos... (Ctrl+C novamente para for√ßar sa√≠da)")
        
        self.cleanup_gracioso()
        sys.exit(0)
    
    def handler_sigterm(self, signum, frame):
        """Handler para SIGTERM"""
        print("\n\n‚ö†Ô∏è  SIGTERM RECEBIDO")
        self.cleanup_gracioso()
        sys.exit(0)
    
    def cleanup_gracioso(self):
        """Limpeza graciosa de recursos"""
        if self.limpeza_feita:
            return
        
        print("\nüìã LIMPANDO RECURSOS:")
        
        if self.sistema_ferramentas:
            try:
                if hasattr(self.sistema_ferramentas, 'browser') and self.sistema_ferramentas.browser:
                    print("   üåê Fechando navegador...")
                    self.sistema_ferramentas.executar('fechar_navegador', {})
                    print("   ‚úÖ Navegador fechado")
            except Exception as e:
                print(f"   ‚ö†Ô∏è  Erro ao fechar navegador: {e}")
        
        if self.agente and hasattr(self.agente, 'rate_limit_manager'):
            try:
                print("   üìä Salvando estat√≠sticas...")
                stats = self.agente.rate_limit_manager.obter_estatisticas()
                
                stats_file = "Luna/.stats/rate_limit_interrupcao.json"
                os.makedirs(os.path.dirname(stats_file), exist_ok=True)
                
                with open(stats_file, 'w', encoding='utf-8') as f:
                    json.dump({
                        'timestamp': datetime.now().isoformat(),
                        'stats': stats,
                        'motivo': 'interrupcao_ctrl_c'
                    }, f, indent=2)
                
                print(f"   ‚úÖ Estat√≠sticas salvas")
            except Exception as e:
                print(f"   ‚ö†Ô∏è  Erro ao salvar stats: {e}")
        
        self.limpeza_feita = True
        print("\n‚úÖ Limpeza conclu√≠da!")
    
    def cleanup_forcado(self):
        """Limpeza for√ßada"""
        print("üî¥ SA√çDA FOR√áADA - recursos podem n√£o ser limpos!")
        if self.sistema_ferramentas and hasattr(self.sistema_ferramentas, 'browser'):
            try:
                if self.sistema_ferramentas.browser:
                    self.sistema_ferramentas.browser.close()
            except:
                pass
    
    def cleanup_final(self):
        """Cleanup final ao sair"""
        if not self.limpeza_feita:
            self.cleanup_gracioso()


# ============================================================================
# SISTEMA DE RATE LIMITING (COM LIMITES CORRETOS!)
# ============================================================================

class RateLimitManager:
    """Gerencia rate limits com valores OFICIAIS da Anthropic"""
    
    def __init__(self, tier: str = "tier1", modo: str = "balanceado"):
        # ‚úÖ LIMITES CORRETOS (Fonte: Alex Albert - Anthropic)
        self.limites = {
            "tier1": {"rpm": 50, "itpm": 30000, "otpm": 8000},
            "tier2": {"rpm": 1000, "itpm": 450000, "otpm": 90000},      # ‚úÖ CORRIGIDO!
            "tier3": {"rpm": 2000, "itpm": 800000, "otpm": 160000},     # ‚úÖ CORRIGIDO!
            "tier4": {"rpm": 4000, "itpm": 2000000, "otpm": 400000}     # ‚úÖ CORRIGIDO!
        }
        
        self.tier = tier
        self.limite_rpm = self.limites[tier]["rpm"]
        self.limite_itpm = self.limites[tier]["itpm"]
        self.limite_otpm = self.limites[tier]["otpm"]
        
        # Modos de opera√ß√£o
        self.modos = {
            "conservador": {"threshold": 0.75},
            "balanceado": {"threshold": 0.85},
            "agressivo": {"threshold": 0.95}
        }
        
        self.modo = modo
        self.threshold = self.modos[modo]["threshold"]
        
        # Tracking
        self.janela_tempo = timedelta(minutes=1)
        self.historico_requisicoes = []
        self.historico_tokens_input = []
        self.historico_tokens_output = []
        
        # Estat√≠sticas
        self.total_requisicoes = 0
        self.total_tokens = 0
        self.total_esperas = 0
        self.tempo_total_espera = 0
        
        print(f"üõ°Ô∏è  Rate Limit Manager: {tier.upper()} - Modo {modo.upper()}", flush=True)
        print(f"   Limites: {self.limite_itpm:,} ITPM | {self.limite_otpm:,} OTPM | {self.limite_rpm} RPM", flush=True)
        print(f"   Threshold: {self.threshold*100:.0f}%", flush=True)
    
    def registrar_uso(self, tokens_input: int, tokens_output: int):
        """Registra uso de tokens e requisi√ß√£o"""
        agora = datetime.now()
        
        self.historico_requisicoes.append(agora)
        self.historico_tokens_input.append((agora, tokens_input))
        self.historico_tokens_output.append((agora, tokens_output))
        
        self.total_requisicoes += 1
        self.total_tokens += (tokens_input + tokens_output)
        
        self._limpar_historico_antigo(agora)
    
    def _limpar_historico_antigo(self, agora):
        """Remove entradas antigas do hist√≥rico"""
        limite_tempo = agora - self.janela_tempo
        
        self.historico_requisicoes = [t for t in self.historico_requisicoes if t > limite_tempo]
        self.historico_tokens_input = [(t, tokens) for t, tokens in self.historico_tokens_input if t > limite_tempo]
        self.historico_tokens_output = [(t, tokens) for t, tokens in self.historico_tokens_output if t > limite_tempo]
    
    def calcular_uso_atual(self):
        """Calcula uso atual (√∫ltima janela de 1 min)"""
        agora = datetime.now()
        self._limpar_historico_antigo(agora)
        
        rpm_atual = len(self.historico_requisicoes)
        itpm_atual = sum(tokens for _, tokens in self.historico_tokens_input)
        otpm_atual = sum(tokens for _, tokens in self.historico_tokens_output)
        
        return {
            "rpm_atual": rpm_atual,
            "itpm_atual": itpm_atual,
            "otpm_atual": otpm_atual,
            "rpm_percent": (rpm_atual / self.limite_rpm) * 100,
            "itpm_percent": (itpm_atual / self.limite_itpm) * 100,
            "otpm_percent": (otpm_atual / self.limite_otpm) * 100,
            "rpm_disponivel": self.limite_rpm - rpm_atual,
            "itpm_disponivel": self.limite_itpm - itpm_atual,
            "otpm_disponivel": self.limite_otpm - otpm_atual
        }
    
    def estimar_tokens_proxima_req(self, tokens_input_estimados: int = None) -> Tuple[int, int]:
        """Estima tokens da pr√≥xima requisi√ß√£o"""
        if tokens_input_estimados is None:
            # Usar m√©dia recente
            if self.historico_tokens_input:
                tokens_input_estimados = int(sum(t for _, t in self.historico_tokens_input[-5:]) / min(5, len(self.historico_tokens_input[-5:])))
            else:
                tokens_input_estimados = 1000
        
        # Estimar output baseado no hist√≥rico
        if self.historico_tokens_output:
            tokens_output_estimados = int(sum(t for _, t in self.historico_tokens_output[-5:]) / min(5, len(self.historico_tokens_output[-5:])))
        else:
            tokens_output_estimados = 1000
        
        return tokens_input_estimados, tokens_output_estimados
    
    def precisa_esperar(self, tokens_input_estimados: int = None, tokens_output_estimados: int = None):
        """Verifica se precisa esperar antes de fazer requisi√ß√£o"""
        uso = self.calcular_uso_atual()
        
        tokens_input_est, tokens_output_est = self.estimar_tokens_proxima_req(tokens_input_estimados)
        
        if tokens_output_estimados is not None:
            tokens_output_est = tokens_output_estimados
        
        # Verificar thresholds
        rpm_ultrapassaria = (uso["rpm_atual"] + 1) > (self.limite_rpm * self.threshold)
        itpm_ultrapassaria = (uso["itpm_atual"] + tokens_input_est) > (self.limite_itpm * self.threshold)
        otpm_ultrapassaria = (uso["otpm_atual"] + tokens_output_est) > (self.limite_otpm * self.threshold)
        
        if rpm_ultrapassaria or itpm_ultrapassaria or otpm_ultrapassaria:
            if self.historico_requisicoes:
                tempo_mais_antigo = min(self.historico_requisicoes)
                tempo_passado = (datetime.now() - tempo_mais_antigo).total_seconds()
                tempo_espera = max(1, int(60 - tempo_passado + 1))
                
                motivos = []
                if rpm_ultrapassaria:
                    motivos.append(f"RPM: {uso['rpm_atual']+1}/{self.limite_rpm}")
                if itpm_ultrapassaria:
                    motivos.append(f"ITPM: {uso['itpm_atual']+tokens_input_est:,}/{self.limite_itpm:,}")
                if otpm_ultrapassaria:
                    motivos.append(f"OTPM: {uso['otpm_atual']+tokens_output_est:,}/{self.limite_otpm:,}")
                
                return True, tempo_espera, ", ".join(motivos)
            
            return True, 5, "Preventivo"
        
        return False, 0, None
    
    def aguardar_se_necessario(self, tokens_input_estimados: int = None, tokens_output_estimados: int = None):
        """Espera se necess√°rio"""
        precisa, segundos, motivo = self.precisa_esperar(tokens_input_estimados, tokens_output_estimados)
        
        if precisa:
            uso = self.calcular_uso_atual()
            print(f"\n‚è≥ Aguardando {segundos}s para respeitar rate limit", flush=True)
            print(f"   Motivo: {motivo}", flush=True)
            print(f"   Uso atual: ITPM {uso['itpm_percent']:.1f}% | OTPM {uso['otpm_percent']:.1f}% | RPM {uso['rpm_percent']:.1f}%", flush=True)
            time.sleep(segundos)
            self.total_esperas += 1
            self.tempo_total_espera += segundos
    
    def exibir_status(self):
        """Mostra status atual"""
        uso = self.calcular_uso_atual()
        
        def barra(percent):
            largura = 20
            preenchido = int((min(percent, 100) / 100) * largura)
            barra_str = "‚ñà" * preenchido + "‚ñë" * (largura - preenchido)
            
            if percent > 95:
                cor = "üî¥"
            elif percent > 85:
                cor = "üü°"
            else:
                cor = "üü¢"
            
            return f"{cor} {barra_str} {min(percent, 100):.1f}%"
        
        print(f"\nüìä STATUS DO RATE LIMIT:", flush=True)
        print(f"   ITPM: {barra(uso['itpm_percent'])} ({uso['itpm_atual']:,}/{self.limite_itpm:,})", flush=True)
        print(f"   OTPM: {barra(uso['otpm_percent'])} ({uso['otpm_atual']:,}/{self.limite_otpm:,})", flush=True)
        print(f"   RPM:  {barra(uso['rpm_percent'])} ({uso['rpm_atual']}/{self.limite_rpm})", flush=True)
    
    def obter_estatisticas(self):
        """Retorna estat√≠sticas gerais"""
        return {
            "total_requisicoes": self.total_requisicoes,
            "total_tokens": self.total_tokens,
            "total_esperas": self.total_esperas,
            "tempo_total_espera": self.tempo_total_espera,
            "media_tokens_req": self.total_tokens / max(1, self.total_requisicoes),
        }


# ============================================================================
# SISTEMA DE PLANEJAMENTO AVAN√áADO
# ============================================================================

class PlanificadorAvancado:
    """
    Sistema de planejamento em 3 fases:
    1. AN√ÅLISE: Entende a tarefa profundamente (~30k tokens)
    2. ESTRAT√âGIA: Cria plano otimizado (~20k tokens)
    3. DECOMPOSI√á√ÉO: Divide em subtarefas paralelas (~15k tokens)
    """
    
    def __init__(self, agente):
        self.agente = agente
        self.historico_planos = []
        self.metricas = {
            'planos_criados': 0,
            'taxa_sucesso': 0,
            'tempo_medio_economizado': 0
        }
    
    def planejar(self, tarefa: str, contexto: dict = None) -> Plano:
        """Cria um plano detalhado de execu√ß√£o"""
        print("\nüß† SISTEMA DE PLANEJAMENTO ATIVADO")
        print("="*70)
        
        # Fase 1: AN√ÅLISE PROFUNDA (~30k tokens)
        print("\nüìä FASE 1: An√°lise Profunda da Tarefa...", flush=True)
        analise = self._analisar_tarefa(tarefa, contexto)
        
        # Fase 2: ESTRAT√âGIA (~20k tokens)
        print("\nüéØ FASE 2: Cria√ß√£o de Estrat√©gia Otimizada...", flush=True)
        estrategia = self._criar_estrategia(tarefa, analise)
        
        # Fase 3: DECOMPOSI√á√ÉO (~15k tokens)
        print("\nüìã FASE 3: Decomposi√ß√£o em Subtarefas...", flush=True)
        decomposicao = self._decompor_em_subtarefas(estrategia)
        
        # Criar ondas de execu√ß√£o
        ondas = self._criar_ondas(decomposicao)
        
        # Criar objeto Plano
        plano = Plano(
            tarefa_original=tarefa,
            analise=analise,
            estrategia=estrategia,
            decomposicao=decomposicao,
            ondas=ondas,
            criado_em=datetime.now()
        )
        
        self.historico_planos.append(plano)
        self.metricas['planos_criados'] += 1
        
        print(f"\n‚úÖ PLANO CRIADO!")
        print(f"   Subtarefas: {len([st for onda in ondas for st in onda.subtarefas])}")
        print(f"   Ondas de execu√ß√£o: {len(ondas)}")
        
        return plano
    
    def _analisar_tarefa(self, tarefa: str, contexto: dict) -> dict:
        """Fase 1: An√°lise profunda da tarefa"""
        prompt = f"""AN√ÅLISE PROFUNDA DA TAREFA

Tarefa solicitada:
{tarefa}

Contexto adicional:
{json.dumps(contexto, indent=2) if contexto else 'Nenhum'}

Fa√ßa uma an√°lise EXTREMAMENTE detalhada e retorne JSON:

{{
    "requisitos_explicitos": ["lista de requisitos mencionados diretamente"],
    "requisitos_implicitos": ["lista de requisitos n√£o mencionados mas necess√°rios"],
    "dependencias": {{
        "ferramentas": ["lista de ferramentas necess√°rias"],
        "bibliotecas": ["lista de bibliotecas Python necess√°rias"],
        "arquivos": ["lista de arquivos necess√°rios"]
    }},
    "riscos": [
        {{"descricao": "...", "probabilidade": "alta/media/baixa", "impacto": "alto/medio/baixo"}}
    ],
    "estimativa_complexidade": "simples/media/complexa/muito_complexa",
    "tempo_estimado": "tempo estimado total",
    "conhecimento_previo_relevante": ["aprendizados relevantes"]
}}

Responda APENAS com o JSON, sem texto adicional."""

        resultado = self.agente._executar_requisicao_simples(prompt, max_tokens=4096)
        
        try:
            # Limpar markdown se houver
            resultado_limpo = resultado.strip()
            if resultado_limpo.startswith("```json"):
                resultado_limpo = resultado_limpo[7:]
            if resultado_limpo.endswith("```"):
                resultado_limpo = resultado_limpo[:-3]
            
            return json.loads(resultado_limpo.strip())
        except:
            return {
                "requisitos_explicitos": [tarefa],
                "requisitos_implicitos": [],
                "dependencias": {"ferramentas": [], "bibliotecas": [], "arquivos": []},
                "riscos": [],
                "estimativa_complexidade": "media",
                "tempo_estimado": "desconhecido"
            }
    
    def _criar_estrategia(self, tarefa: str, analise: dict) -> dict:
        """Fase 2: Cria√ß√£o de estrat√©gia otimizada"""
        prompt = f"""CRIA√á√ÉO DE ESTRAT√âGIA OTIMIZADA

Tarefa original:
{tarefa}

An√°lise realizada:
{json.dumps(analise, indent=2)}

Crie a melhor estrat√©gia de execu√ß√£o e retorne JSON:

{{
    "abordagem": "descri√ß√£o da abordagem principal",
    "justificativa": "por que esta abordagem √© a melhor",
    "sequencia_otima": [
        {{"ordem": 1, "acao": "descri√ß√£o da a√ß√£o", "razao": "por que fazer primeiro"}}
    ],
    "oportunidades_paralelizacao": [
        {{"acoes": ["acao1", "acao2"], "ganho_estimado": "estimativa de ganho"}}
    ],
    "pontos_validacao": [
        {{"apos": "qual a√ß√£o", "validar": "o que validar", "criterio_sucesso": "como saber que est√° certo"}}
    ],
    "planos_contingencia": ["plano B caso algo falhe"]
}}

Responda APENAS com o JSON, sem texto adicional."""

        resultado = self.agente._executar_requisicao_simples(prompt, max_tokens=4096)
        
        try:
            resultado_limpo = resultado.strip()
            if resultado_limpo.startswith("```json"):
                resultado_limpo = resultado_limpo[7:]
            if resultado_limpo.endswith("```"):
                resultado_limpo = resultado_limpo[:-3]
            
            return json.loads(resultado_limpo.strip())
        except:
            return {
                "abordagem": "execu√ß√£o direta",
                "justificativa": "abordagem simples",
                "sequencia_otima": [],
                "oportunidades_paralelizacao": [],
                "pontos_validacao": []
            }
    
    def _decompor_em_subtarefas(self, estrategia: dict) -> dict:
        """Fase 3: Decomposi√ß√£o em subtarefas execut√°veis"""
        prompt = f"""DECOMPOSI√á√ÉO EM SUBTAREFAS EXECUT√ÅVEIS

Estrat√©gia definida:
{json.dumps(estrategia, indent=2)}

Decomponha em subtarefas CONCRETAS e EXECUT√ÅVEIS. Retorne JSON:

{{
    "ondas": [
        {{
            "numero": 1,
            "descricao": "descri√ß√£o da onda",
            "subtarefas": [
                {{
                    "id": "1.1",
                    "titulo": "t√≠tulo curto",
                    "descricao": "descri√ß√£o detalhada",
                    "ferramentas": ["lista de ferramentas"],
                    "input": "input esperado",
                    "output_esperado": "output esperado",
                    "criterio_sucesso": "como validar",
                    "tokens_estimados": 5000,
                    "tempo_estimado": "30s",
                    "prioridade": "critica",
                    "dependencias": []
                }}
            ],
            "pode_executar_paralelo": true
        }}
    ],
    "total_subtarefas": 0,
    "tempo_estimado_sequencial": "tempo",
    "tempo_estimado_paralelo": "tempo"
}}

Responda APENAS com o JSON, sem texto adicional."""

        resultado = self.agente._executar_requisicao_simples(prompt, max_tokens=4096)
        
        try:
            resultado_limpo = resultado.strip()
            if resultado_limpo.startswith("```json"):
                resultado_limpo = resultado_limpo[7:]
            if resultado_limpo.endswith("```"):
                resultado_limpo = resultado_limpo[:-3]
            
            decomp = json.loads(resultado_limpo.strip())
            # Atualizar total
            decomp['total_subtarefas'] = sum(len(onda.get('subtarefas', [])) for onda in decomp.get('ondas', []))
            return decomp
        except Exception as e:
            print(f"   ‚ö†Ô∏è  Erro ao parsear decomposi√ß√£o: {e}")
            return {
                "ondas": [],
                "total_subtarefas": 0,
                "tempo_estimado_sequencial": "desconhecido",
                "tempo_estimado_paralelo": "desconhecido"
            }
    
    def _criar_ondas(self, decomposicao: dict) -> List[Onda]:
        """Cria objetos Onda a partir da decomposi√ß√£o"""
        ondas = []
        
        for onda_dict in decomposicao.get('ondas', []):
            subtarefas = []
            
            for st_dict in onda_dict.get('subtarefas', []):
                subtarefa = Subtarefa(
                    id=st_dict.get('id', ''),
                    titulo=st_dict.get('titulo', ''),
                    descricao=st_dict.get('descricao', ''),
                    ferramentas=st_dict.get('ferramentas', []),
                    input_esperado=st_dict.get('input', ''),
                    output_esperado=st_dict.get('output_esperado', ''),
                    criterio_sucesso=st_dict.get('criterio_sucesso', ''),
                    tokens_estimados=st_dict.get('tokens_estimados', 5000),
                    tempo_estimado=st_dict.get('tempo_estimado', '30s'),
                    prioridade=st_dict.get('prioridade', 'importante'),
                    dependencias=st_dict.get('dependencias', [])
                )
                subtarefas.append(subtarefa)
            
            onda = Onda(
                numero=onda_dict.get('numero', 0),
                descricao=onda_dict.get('descricao', ''),
                subtarefas=subtarefas,
                pode_executar_paralelo=onda_dict.get('pode_executar_paralelo', False)
            )
            ondas.append(onda)
        
        return ondas
    
    def executar_plano(self, plano: Plano) -> dict:
        """Executa o plano criado"""
        print("\nüöÄ EXECUTANDO PLANO...")
        print("="*70)
        
        resultados = {}
        falhas = []
        
        for onda in plano.ondas:
            print(f"\nüåä ONDA {onda.numero}: {onda.descricao}")
            print(f"   Subtarefas: {len(onda.subtarefas)}")
            print(f"   Paralelo: {'‚úÖ' if onda.pode_executar_paralelo else '‚ùå'}")
            
            if onda.pode_executar_paralelo and len(onda.subtarefas) > 1:
                # Usar processador paralelo
                if hasattr(self.agente, 'processador_paralelo'):
                    resultados_onda = self.agente.processador_paralelo._processar_ondas_paralelas([onda])
                else:
                    # Fallback: execu√ß√£o sequencial
                    resultados_onda = self._executar_onda_sequencial(onda)
            else:
                resultados_onda = self._executar_onda_sequencial(onda)
            
            # Processar resultados
            for subtarefa_id, resultado in resultados_onda.items():
                if resultado.get('sucesso'):
                    resultados[subtarefa_id] = resultado
                    print(f"   ‚úÖ {subtarefa_id}: Conclu√≠da")
                else:
                    falhas.append({
                        'subtarefa_id': subtarefa_id,
                        'erro': resultado.get('erro'),
                        'onda': onda.numero
                    })
                    print(f"   ‚ùå {subtarefa_id}: Falhou - {resultado.get('erro', 'erro desconhecido')}")
        
        resultado_final = {
            'sucesso': len(falhas) == 0,
            'total_subtarefas': sum(len(o.subtarefas) for o in plano.ondas),
            'concluidas': len(resultados),
            'falhas': len(falhas),
            'resultados': resultados,
            'detalhes_falhas': falhas
        }
        
        print("\n" + "="*70)
        if resultado_final['sucesso']:
            print("üéâ PLANO EXECUTADO COM SUCESSO!")
        else:
            print(f"‚ö†Ô∏è  PLANO PARCIALMENTE EXECUTADO ({resultado_final['concluidas']}/{resultado_final['total_subtarefas']})")
        
        return resultado_final
    
    def _executar_onda_sequencial(self, onda: Onda) -> dict:
        """Executa ondas sequencialmente"""
        resultados = {}
        
        for st in onda.subtarefas:
            try:
                prompt = f"""SUBTAREFA {st.id}: {st.titulo}

DESCRI√á√ÉO:
{st.descricao}

INPUT:
{st.input_esperado}

OUTPUT ESPERADO:
{st.output_esperado}

CRIT√âRIO DE SUCESSO:
{st.criterio_sucesso}

Execute esta subtarefa de forma completa e precisa."""
                
                resultado_texto = self.agente._executar_requisicao_simples(prompt, max_tokens=2048)
                
                resultados[st.id] = {
                    'sucesso': True,
                    'output': resultado_texto
                }
            except Exception as e:
                resultados[st.id] = {
                    'sucesso': False,
                    'erro': str(e)
                }
        
        return resultados


# ============================================================================
# PROCESSADOR PARALELO AGRESSIVO
# ============================================================================

class ProcessadorParalelo:
    """Executa m√∫ltiplas tarefas simultaneamente (Tier 2: 15-20 workers)"""
    
    def __init__(self, agente, max_workers: int = 15):
        self.agente = agente
        self.max_workers = max_workers
        self.semaphore = threading.Semaphore(max_workers)
        self.estatisticas = {
            'tarefas_processadas': 0,
            'tempo_total_economizado': 0
        }
    
    def processar_lista(self, tarefas: List[str]) -> List[str]:
        """Processa lista de tarefas em paralelo"""
        print(f"\nüöÄ PROCESSAMENTO PARALELO INICIADO")
        print(f"   Total tarefas: {len(tarefas)}")
        print(f"   Workers: {self.max_workers}")
        print("="*70)
        
        inicio = time.time()
        resultados = []
        
        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            futures = {
                executor.submit(self._processar_tarefa, tarefa): i
                for i, tarefa in enumerate(tarefas)
            }
            
            for future in as_completed(futures):
                idx = futures[future]
                try:
                    resultado = future.result()
                    resultados.append((idx, resultado))
                    print(f"   ‚úÖ Tarefa {idx+1}/{len(tarefas)} conclu√≠da")
                except Exception as e:
                    print(f"   ‚ùå Tarefa {idx+1}/{len(tarefas)} falhou: {e}")
                    resultados.append((idx, {'erro': str(e)}))
        
        # Ordenar por √≠ndice original
        resultados.sort(key=lambda x: x[0])
        resultados = [r[1] for r in resultados]
        
        tempo_total = time.time() - inicio
        tempo_sequencial_estimado = len(tarefas) * 30
        tempo_economizado = tempo_sequencial_estimado - tempo_total
        
        self.estatisticas['tarefas_processadas'] += len(tarefas)
        self.estatisticas['tempo_total_economizado'] += tempo_economizado
        
        print(f"\n‚úÖ PROCESSAMENTO PARALELO CONCLU√çDO!")
        print(f"   Tempo: {tempo_total:.1f}s")
        print(f"   Tempo economizado: {tempo_economizado:.1f}s")
        print(f"   Speedup: {tempo_sequencial_estimado/tempo_total:.1f}x")
        
        return resultados
    
    def _processar_tarefa(self, tarefa: str) -> str:
        """Processa uma tarefa individual"""
        with self.semaphore:
            return self.agente._executar_requisicao_simples(tarefa, max_tokens=2048)
    
    def _processar_ondas_paralelas(self, ondas: List[Onda]) -> dict:
        """Processa ondas de subtarefas em paralelo"""
        resultados = {}
        
        for onda in ondas:
            if onda.pode_executar_paralelo and len(onda.subtarefas) > 1:
                with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
                    futures = {
                        executor.submit(self._executar_subtarefa, st): st.id
                        for st in onda.subtarefas
                    }
                    
                    for future in as_completed(futures):
                        subtarefa_id = futures[future]
                        try:
                            resultado = future.result()
                            resultados[subtarefa_id] = resultado
                        except Exception as e:
                            resultados[subtarefa_id] = {
                                'sucesso': False,
                                'erro': str(e)
                            }
            else:
                # Execu√ß√£o sequencial
                for st in onda.subtarefas:
                    resultados[st.id] = self._executar_subtarefa(st)
        
        return resultados
    
    def _executar_subtarefa(self, subtarefa: Subtarefa) -> dict:
        """Executa uma subtarefa"""
        try:
            prompt = f"""SUBTAREFA {subtarefa.id}: {subtarefa.titulo}

{subtarefa.descricao}

Execute de forma completa e precisa."""
            
            resultado = self.agente._executar_requisicao_simples(prompt, max_tokens=2048)
            
            return {
                'sucesso': True,
                'output': resultado
            }
        except Exception as e:
            return {
                'sucesso': False,
                'erro': str(e)
            }


# ============================================================================
# SISTEMA DE FERRAMENTAS (PLACEHOLDER - USAR C√ìDIGO COMPLETO ORIGINAL)
# ============================================================================

class SistemaFerramentasCompleto:
    """Sistema de ferramentas simplificado para demonstra√ß√£o"""
    
    def __init__(self, master_password: str = None, usar_memoria: bool = True):
        self.ferramentas_descricao = []
        self.ferramentas_codigo = {}
        self.browser = None
        self.page = None
        
        # Carregar ferramentas b√°sicas
        self._carregar_ferramentas_base()
    
    def _carregar_ferramentas_base(self):
        """Carregar ferramentas b√°sicas (bash, arquivos, etc)"""
        # Adicionar ferramentas b√°sicas aqui
        # (usar c√≥digo completo do arquivo original)
        pass
    
    def adicionar_ferramenta(self, nome: str, codigo: str, descricao: str, parametros: dict):
        """Adiciona ferramenta"""
        self.ferramentas_codigo[nome] = codigo
        
        self.ferramentas_descricao.append({
            "name": nome,
            "description": descricao,
            "input_schema": {
                "type": "object",
                "properties": parametros,
                "required": list(parametros.keys()) if parametros else []
            }
        })
    
    def executar(self, nome: str, parametros: dict) -> str:
        """Executa ferramenta"""
        if nome not in self.ferramentas_codigo:
            return f"ERRO: Ferramenta '{nome}' n√£o existe"
        
        # Executar c√≥digo da ferramenta
        try:
            namespace = {'__builtins__': __builtins__}
            exec(self.ferramentas_codigo[nome], namespace)
            
            func = namespace.get(nome)
            if func:
                return str(func(**parametros))
            
            return "ERRO: Fun√ß√£o n√£o encontrada"
        except Exception as e:
            return f"ERRO: {e}"
    
    def obter_descricoes(self) -> list:
        """Retorna descri√ß√µes das ferramentas"""
        return self.ferramentas_descricao


# ============================================================================
# AGENTE COMPLETO COM TODAS AS FUNCIONALIDADES
# ============================================================================

class AgenteComTier2Completo:
    """Agente com Tier 2, Planejamento Avan√ßado e Processamento Paralelo"""
    
    def __init__(
        self, 
        api_key: str, 
        master_password: str = None, 
        usar_memoria: bool = True,
        tier: str = "tier2",
        modo_rate_limit: str = "agressivo",
        usar_planejamento: bool = True,
        usar_paralelismo: bool = True
    ):
        self.client = anthropic.Anthropic(api_key=api_key)
        self.sistema_ferramentas = SistemaFerramentasCompleto(master_password, usar_memoria)
        self.historico_conversa = []
        self.max_iteracoes_atual = 40
        
        # Rate limit manager com modo configur√°vel
        self.rate_limit_manager = RateLimitManager(tier=tier, modo=modo_rate_limit)
        
        # Sistema de planejamento
        self.usar_planejamento = usar_planejamento
        self.planificador = PlanificadorAvancado(self) if usar_planejamento else None
        
        # Sistema de paralelismo
        self.usar_paralelismo = usar_paralelismo
        # Tier 2: 15-20 workers
        max_workers = 15 if tier == "tier2" else (20 if tier in ["tier3", "tier4"] else 5)
        self.processador_paralelo = ProcessadorParalelo(self, max_workers=max_workers) if usar_paralelismo else None
        
        # Sistema de recupera√ß√£o de erros
        self.modo_recuperacao = False
        self.erros_recentes = []
    
    def _executar_requisicao_simples(self, prompt: str, max_tokens: int = 4096) -> str:
        """Executa uma requisi√ß√£o simples √† API"""
        self.rate_limit_manager.aguardar_se_necessario()
        
        try:
            response = self.client.messages.create(
                model="claude-sonnet-4-5-20250929",
                max_tokens=max_tokens,
                messages=[{"role": "user", "content": prompt}]
            )
            
            # Registrar uso
            tokens_input = response.usage.input_tokens
            tokens_output = response.usage.output_tokens
            self.rate_limit_manager.registrar_uso(tokens_input, tokens_output)
            
            # Extrair texto
            texto = ""
            for block in response.content:
                if hasattr(block, "text"):
                    texto += block.text
            
            return texto
            
        except RateLimitError as e:
            print(f"\n‚ö†Ô∏è  RATE LIMIT ATINGIDO! Aguardando 60s...")
            time.sleep(60)
            return self._executar_requisicao_simples(prompt, max_tokens)
        except Exception as e:
            return f"ERRO: {e}"
    
    def _tarefa_e_complexa(self, tarefa: str) -> bool:
        """Detecta se tarefa √© complexa o suficiente para planejamento"""
        indicadores_complexidade = [
            'criar', 'desenvolver', 'implementar', 'sistema', 'completo',
            'api', 'aplica√ß√£o', 'projeto', 'arquitetura', 'integrar',
            'm√∫ltiplos', 'v√°rios', 'todos', 'completo', 'end-to-end'
        ]
        
        tarefa_lower = tarefa.lower()
        matches = sum(1 for ind in indicadores_complexidade if ind in tarefa_lower)
        
        return matches >= 2 or len(tarefa) > 200
    
    def executar_tarefa(self, tarefa: str, max_iteracoes: int = None, usar_planejamento_forcado: bool = None):
        """Executa tarefa com planejamento e paralelismo"""
        
        if max_iteracoes is None:
            max_iteracoes = self.max_iteracoes_atual
        
        print("\n" + "="*70)
        print(f"üéØ TAREFA: {tarefa}")
        print("="*70)
        
        # Decidir se usa planejamento
        usar_plan = usar_planejamento_forcado if usar_planejamento_forcado is not None else (
            self.usar_planejamento and self._tarefa_e_complexa(tarefa)
        )
        
        if usar_plan and self.planificador:
            print("\nüß† Tarefa complexa detectada. Ativando sistema de planejamento...")
            
            # Criar plano
            plano = self.planificador.planejar(tarefa)
            
            # Salvar plano
            plano_path = f"Luna/planos/plano_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
            plano.salvar(plano_path)
            print(f"   üíæ Plano salvo em: {plano_path}")
            
            # Executar plano
            resultado = self.planificador.executar_plano(plano)
            
            return resultado
        else:
            # Execu√ß√£o normal (sem planejamento)
            print("\n‚ö° Execu√ß√£o direta (sem planejamento)")
            resultado = self._executar_requisicao_simples(tarefa, max_tokens=4096)
            
            print("\n" + "="*70)
            print("‚úÖ CONCLU√çDO!")
            print("="*70)
            print(resultado)
            
            return resultado


# ============================================================================
# INTERFACE PRINCIPAL
# ============================================================================

def main():
    print("""
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  üåô LUNA V3 - TIER 2 COMPLETO + PLANEJAMENTO + PARALELISMO

  ‚úÖ Limites corretos (1000 RPM, 450K ITPM, 90K OTPM)
  üß† Sistema de Planejamento Avan√ßado
  üîÑ Processamento Paralelo (15-20 tarefas simult√¢neas)
  üõ°Ô∏è Rate Limiting Inteligente
  üõë Handler de Interrup√ß√£o (Ctrl+C)

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    """)
    
    # ‚úÖ CORRE√á√ÉO CR√çTICA: Carregar vari√°veis de ambiente do .env
    load_dotenv()
    
    api_key = os.getenv('ANTHROPIC_API_KEY')
    if not api_key:
        print("‚ùå Configure ANTHROPIC_API_KEY no .env")
        return
    
    # Configurar tier
    print("\nüõ°Ô∏è  CONFIGURA√á√ÉO")
    print("   Qual √© o seu tier da API Anthropic?")
    print("   1. Tier 1 (50 RPM, 30K ITPM, 8K OTPM)")
    print("   2. Tier 2 (1000 RPM, 450K ITPM, 90K OTPM) ‚Üê RECOMENDADO")
    print("   3. Tier 3 (2000 RPM, 800K ITPM, 160K OTPM)")
    print("   4. Tier 4 (4000 RPM, 2M ITPM, 400K OTPM)")
    
    tier_input = input("\n   Escolha (1-4, Enter=2): ").strip()
    tier_map = {"1": "tier1", "2": "tier2", "3": "tier3", "4": "tier4", "": "tier2"}
    tier = tier_map.get(tier_input, "tier2")
    
    # Configurar modo
    print("\n   Modo de rate limiting:")
    print("   1. Conservador (75% threshold)")
    print("   2. Balanceado (85% threshold)")
    print("   3. Agressivo (95% threshold) ‚Üê RECOMENDADO para Tier 2+")
    
    modo_input = input("\n   Escolha (1-3, Enter=3): ").strip()
    modo_map = {"1": "conservador", "2": "balanceado", "3": "agressivo", "": "agressivo"}
    modo = modo_map.get(modo_input, "agressivo")
    
    # Criar agente
    try:
        agente = AgenteComTier2Completo(
            api_key, 
            tier=tier,
            modo_rate_limit=modo,
            usar_planejamento=True,
            usar_paralelismo=True
        )
    except Exception as e:
        print(f"\n‚ùå Erro ao criar agente: {e}")
        return
    
    # Criar handler de interrup√ß√£o
    handler = InterruptHandler(agente=agente, sistema_ferramentas=agente.sistema_ferramentas)
    
    print("\n‚úÖ Luna V3 iniciada!")
    print("   üß† Sistema de Planejamento: ATIVADO")
    print("   üîÑ Processamento Paralelo: ATIVADO")
    print(f"   üõ°Ô∏è  Rate Limit: {tier.upper()} - {modo.upper()}")
    
    print("\nüí° DICA: Para tarefas complexas, a Luna criar√° um plano detalhado antes de executar!")
    print("üõë DICA: Pressione Ctrl+C para interromper graciosamente")
    
    # Loop principal
    while True:
        try:
            print("\n" + "‚îÄ"*70)
            comando = input("\nüí¨ O que voc√™ quer? (ou 'sair'): ").strip()
            
            if comando.lower() in ['sair', 'exit', 'quit', '']:
                print("\nüëã At√© logo!")
                
                # Estat√≠sticas finais
                print("\nüìä ESTAT√çSTICAS FINAIS:")
                stats = agente.rate_limit_manager.obter_estatisticas()
                print(f"   Requisi√ß√µes: {stats['total_requisicoes']}")
                print(f"   Tokens: {stats['total_tokens']:,}")
                print(f"   M√©dia tokens/req: {stats['media_tokens_req']:.0f}")
                if stats['total_esperas'] > 0:
                    print(f"   Esperas: {stats['total_esperas']} ({stats['tempo_total_espera']:.0f}s total)")
                
                if agente.planificador:
                    print(f"\n   üß† Planos criados: {agente.planificador.metricas['planos_criados']}")
                
                if agente.processador_paralelo:
                    print(f"   üîÑ Tarefas paralelas: {agente.processador_paralelo.estatisticas['tarefas_processadas']}")
                
                break
            
            # Executar tarefa
            agente.executar_tarefa(comando)
            input("\n‚è∏Ô∏è  Pressione ENTER para continuar...")
            
        except KeyboardInterrupt:
            break
        except Exception as e:
            print(f"\n‚ùå Erro inesperado: {e}")
            import traceback
            traceback.print_exc()


if __name__ == "__main__":
    main()
