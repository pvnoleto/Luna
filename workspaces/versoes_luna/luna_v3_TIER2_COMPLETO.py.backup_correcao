#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
🚀 LUNA V3 - COM TIER 2 CORRIGIDO + PLANEJAMENTO AVANÇADO + PROCESSAMENTO PARALELO
===================================================================================

✨ NOVIDADES DESTA VERSÃO:
1. ✅ LIMITES CORRETOS: Tier 2 = 1000 RPM, 450K ITPM, 90K OTPM (OFICIAL!)
2. 🧠 SISTEMA DE PLANEJAMENTO AVANÇADO: Planos detalhados antes de executar
3. 🔄 PROCESSAMENTO PARALELO AGRESSIVO: 15-20 tarefas simultâneas
4. 🛡️ ANTI-RATE LIMIT: Monitora e previne erros 429
5. 🔧 RECUPERAÇÃO INTELIGENTE: Prioriza corrigir erros
6. 🛑 HANDLER DE INTERRUPÇÃO: Ctrl+C tratado graciosamente

VALORES OFICIAIS DOS TIERS (Fonte: Alex Albert - Anthropic):
┌────────┬─────────┬────────────┬────────────┐
│ Tier   │ RPM     │ ITPM       │ OTPM       │
├────────┼─────────┼────────────┼────────────┤
│ Tier 1 │ 50      │ 30,000     │ 8,000      │
│ Tier 2 │ 1,000   │ 450,000    │ 90,000     │  ← CORRIGIDO!
│ Tier 3 │ 2,000   │ 800,000    │ 160,000    │  ← CORRIGIDO!
│ Tier 4 │ 4,000   │ 2,000,000  │ 400,000    │  ← CORRIGIDO!
└────────┴─────────┴────────────┴────────────┘

Versão: 2025-10-17 (Tier 2 Completo + Planejamento + Paralelismo)
"""

import anthropic
from anthropic import BadRequestError, RateLimitError
import os
import sys
import subprocess
import json
from dotenv import load_dotenv
from datetime import datetime, timedelta
import getpass
from pathlib import Path
import time
import signal
import atexit
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional, Tuple
from concurrent.futures import ThreadPoolExecutor, as_completed
import threading

# Configuração UTF-8
os.environ.setdefault("PYTHONUTF8", "1")
os.environ.setdefault("PYTHONIOENCODING", "utf-8")
os.environ["PYTHONUNBUFFERED"] = "1"

if sys.platform == 'win32':
    try:
        import codecs
        sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer, 'strict')
        sys.stderr = codecs.getwriter('utf-8')(sys.stderr.buffer, 'strict')
    except:
        pass

sys.stdout.reconfigure(line_buffering=True) if hasattr(sys.stdout, 'reconfigure') else None
sys.stderr.reconfigure(line_buffering=True) if hasattr(sys.stderr, 'reconfigure') else None


# ============================================================================
# CLASSES DE DADOS PARA PLANEJAMENTO
# ============================================================================

@dataclass
class Subtarefa:
    """Representa uma subtarefa executável"""
    id: str
    titulo: str
    descricao: str
    ferramentas: List[str]
    input_esperado: str
    output_esperado: str
    criterio_sucesso: str
    tokens_estimados: int
    tempo_estimado: str
    prioridade: str  # critica, importante, nice-to-have
    dependencias: List[str] = field(default_factory=list)
    concluida: bool = False
    resultado: Optional[str] = None


@dataclass
class Onda:
    """Representa uma onda de execução (subtarefas paralelas/sequenciais)"""
    numero: int
    descricao: str
    subtarefas: List[Subtarefa]
    pode_executar_paralelo: bool
    concluida: bool = False


@dataclass
class Plano:
    """Representa um plano completo de execução"""
    tarefa_original: str
    analise: Dict[str, Any]
    estrategia: Dict[str, Any]
    decomposicao: Dict[str, Any]
    ondas: List[Onda]
    criado_em: datetime
    executado_em: Optional[datetime] = None
    resultado: Optional[Dict[str, Any]] = None
    
    def salvar(self, caminho: str):
        """Salva o plano em arquivo JSON"""
        os.makedirs(os.path.dirname(caminho), exist_ok=True)
        
        with open(caminho, 'w', encoding='utf-8') as f:
            json.dump({
                'tarefa_original': self.tarefa_original,
                'analise': self.analise,
                'estrategia': self.estrategia,
                'decomposicao': self.decomposicao,
                'criado_em': self.criado_em.isoformat(),
                'executado_em': self.executado_em.isoformat() if self.executado_em else None,
                'resultado': self.resultado
            }, f, indent=2, ensure_ascii=False)


# ============================================================================
# HANDLER DE INTERRUPÇÃO
# ============================================================================

class InterruptHandler:
    """Gerencia interrupções graciosamente"""
    
    def __init__(self, agente=None, sistema_ferramentas=None):
        self.agente = agente
        self.sistema_ferramentas = sistema_ferramentas
        self.interrompido = False
        self.limpeza_feita = False
        
        signal.signal(signal.SIGINT, self.handler_sigint)
        signal.signal(signal.SIGTERM, self.handler_sigterm)
        atexit.register(self.cleanup_final)
        
        print("✅ Handler de interrupção ativado (Ctrl+C será tratado graciosamente)")
    
    def handler_sigint(self, signum, frame):
        """Handler para Ctrl+C"""
        if self.interrompido:
            print("\n\n🔴 FORÇANDO SAÍDA... (segunda interrupção)")
            self.cleanup_forcado()
            sys.exit(1)
        
        self.interrompido = True
        print("\n\n⚠️  INTERRUPÇÃO DETECTADA (Ctrl+C)")
        print("   Limpando recursos... (Ctrl+C novamente para forçar saída)")
        
        self.cleanup_gracioso()
        sys.exit(0)
    
    def handler_sigterm(self, signum, frame):
        """Handler para SIGTERM"""
        print("\n\n⚠️  SIGTERM RECEBIDO")
        self.cleanup_gracioso()
        sys.exit(0)
    
    def cleanup_gracioso(self):
        """Limpeza graciosa de recursos"""
        if self.limpeza_feita:
            return
        
        print("\n📋 LIMPANDO RECURSOS:")
        
        if self.sistema_ferramentas:
            try:
                if hasattr(self.sistema_ferramentas, 'browser') and self.sistema_ferramentas.browser:
                    print("   🌐 Fechando navegador...")
                    self.sistema_ferramentas.executar('fechar_navegador', {})
                    print("   ✅ Navegador fechado")
            except Exception as e:
                print(f"   ⚠️  Erro ao fechar navegador: {e}")
        
        if self.agente and hasattr(self.agente, 'rate_limit_manager'):
            try:
                print("   📊 Salvando estatísticas...")
                stats = self.agente.rate_limit_manager.obter_estatisticas()
                
                stats_file = "Luna/.stats/rate_limit_interrupcao.json"
                os.makedirs(os.path.dirname(stats_file), exist_ok=True)
                
                with open(stats_file, 'w', encoding='utf-8') as f:
                    json.dump({
                        'timestamp': datetime.now().isoformat(),
                        'stats': stats,
                        'motivo': 'interrupcao_ctrl_c'
                    }, f, indent=2)
                
                print(f"   ✅ Estatísticas salvas")
            except Exception as e:
                print(f"   ⚠️  Erro ao salvar stats: {e}")
        
        self.limpeza_feita = True
        print("\n✅ Limpeza concluída!")
    
    def cleanup_forcado(self):
        """Limpeza forçada"""
        print("🔴 SAÍDA FORÇADA - recursos podem não ser limpos!")
        if self.sistema_ferramentas and hasattr(self.sistema_ferramentas, 'browser'):
            try:
                if self.sistema_ferramentas.browser:
                    self.sistema_ferramentas.browser.close()
            except:
                pass
    
    def cleanup_final(self):
        """Cleanup final ao sair"""
        if not self.limpeza_feita:
            self.cleanup_gracioso()


# ============================================================================
# SISTEMA DE RATE LIMITING (COM LIMITES CORRETOS!)
# ============================================================================

class RateLimitManager:
    """Gerencia rate limits com valores OFICIAIS da Anthropic"""
    
    def __init__(self, tier: str = "tier1", modo: str = "balanceado"):
        # ✅ LIMITES CORRETOS (Fonte: Alex Albert - Anthropic)
        self.limites = {
            "tier1": {"rpm": 50, "itpm": 30000, "otpm": 8000},
            "tier2": {"rpm": 1000, "itpm": 450000, "otpm": 90000},      # ✅ CORRIGIDO!
            "tier3": {"rpm": 2000, "itpm": 800000, "otpm": 160000},     # ✅ CORRIGIDO!
            "tier4": {"rpm": 4000, "itpm": 2000000, "otpm": 400000}     # ✅ CORRIGIDO!
        }
        
        self.tier = tier
        self.limite_rpm = self.limites[tier]["rpm"]
        self.limite_itpm = self.limites[tier]["itpm"]
        self.limite_otpm = self.limites[tier]["otpm"]
        
        # Modos de operação
        self.modos = {
            "conservador": {"threshold": 0.75},
            "balanceado": {"threshold": 0.85},
            "agressivo": {"threshold": 0.95}
        }
        
        self.modo = modo
        self.threshold = self.modos[modo]["threshold"]
        
        # Tracking
        self.janela_tempo = timedelta(minutes=1)
        self.historico_requisicoes = []
        self.historico_tokens_input = []
        self.historico_tokens_output = []
        
        # Estatísticas
        self.total_requisicoes = 0
        self.total_tokens = 0
        self.total_esperas = 0
        self.tempo_total_espera = 0
        
        print(f"🛡️  Rate Limit Manager: {tier.upper()} - Modo {modo.upper()}", flush=True)
        print(f"   Limites: {self.limite_itpm:,} ITPM | {self.limite_otpm:,} OTPM | {self.limite_rpm} RPM", flush=True)
        print(f"   Threshold: {self.threshold*100:.0f}%", flush=True)
    
    def registrar_uso(self, tokens_input: int, tokens_output: int):
        """Registra uso de tokens e requisição"""
        agora = datetime.now()
        
        self.historico_requisicoes.append(agora)
        self.historico_tokens_input.append((agora, tokens_input))
        self.historico_tokens_output.append((agora, tokens_output))
        
        self.total_requisicoes += 1
        self.total_tokens += (tokens_input + tokens_output)
        
        self._limpar_historico_antigo(agora)
    
    def _limpar_historico_antigo(self, agora):
        """Remove entradas antigas do histórico"""
        limite_tempo = agora - self.janela_tempo
        
        self.historico_requisicoes = [t for t in self.historico_requisicoes if t > limite_tempo]
        self.historico_tokens_input = [(t, tokens) for t, tokens in self.historico_tokens_input if t > limite_tempo]
        self.historico_tokens_output = [(t, tokens) for t, tokens in self.historico_tokens_output if t > limite_tempo]
    
    def calcular_uso_atual(self):
        """Calcula uso atual (última janela de 1 min)"""
        agora = datetime.now()
        self._limpar_historico_antigo(agora)
        
        rpm_atual = len(self.historico_requisicoes)
        itpm_atual = sum(tokens for _, tokens in self.historico_tokens_input)
        otpm_atual = sum(tokens for _, tokens in self.historico_tokens_output)
        
        return {
            "rpm_atual": rpm_atual,
            "itpm_atual": itpm_atual,
            "otpm_atual": otpm_atual,
            "rpm_percent": (rpm_atual / self.limite_rpm) * 100,
            "itpm_percent": (itpm_atual / self.limite_itpm) * 100,
            "otpm_percent": (otpm_atual / self.limite_otpm) * 100,
            "rpm_disponivel": self.limite_rpm - rpm_atual,
            "itpm_disponivel": self.limite_itpm - itpm_atual,
            "otpm_disponivel": self.limite_otpm - otpm_atual
        }
    
    def estimar_tokens_proxima_req(self, tokens_input_estimados: int = None) -> Tuple[int, int]:
        """Estima tokens da próxima requisição"""
        if tokens_input_estimados is None:
            # Usar média recente
            if self.historico_tokens_input:
                tokens_input_estimados = int(sum(t for _, t in self.historico_tokens_input[-5:]) / min(5, len(self.historico_tokens_input[-5:])))
            else:
                tokens_input_estimados = 1000
        
        # Estimar output baseado no histórico
        if self.historico_tokens_output:
            tokens_output_estimados = int(sum(t for _, t in self.historico_tokens_output[-5:]) / min(5, len(self.historico_tokens_output[-5:])))
        else:
            tokens_output_estimados = 1000
        
        return tokens_input_estimados, tokens_output_estimados
    
    def precisa_esperar(self, tokens_input_estimados: int = None, tokens_output_estimados: int = None):
        """Verifica se precisa esperar antes de fazer requisição"""
        uso = self.calcular_uso_atual()
        
        tokens_input_est, tokens_output_est = self.estimar_tokens_proxima_req(tokens_input_estimados)
        
        if tokens_output_estimados is not None:
            tokens_output_est = tokens_output_estimados
        
        # Verificar thresholds
        rpm_ultrapassaria = (uso["rpm_atual"] + 1) > (self.limite_rpm * self.threshold)
        itpm_ultrapassaria = (uso["itpm_atual"] + tokens_input_est) > (self.limite_itpm * self.threshold)
        otpm_ultrapassaria = (uso["otpm_atual"] + tokens_output_est) > (self.limite_otpm * self.threshold)
        
        if rpm_ultrapassaria or itpm_ultrapassaria or otpm_ultrapassaria:
            if self.historico_requisicoes:
                tempo_mais_antigo = min(self.historico_requisicoes)
                tempo_passado = (datetime.now() - tempo_mais_antigo).total_seconds()
                tempo_espera = max(1, int(60 - tempo_passado + 1))
                
                motivos = []
                if rpm_ultrapassaria:
                    motivos.append(f"RPM: {uso['rpm_atual']+1}/{self.limite_rpm}")
                if itpm_ultrapassaria:
                    motivos.append(f"ITPM: {uso['itpm_atual']+tokens_input_est:,}/{self.limite_itpm:,}")
                if otpm_ultrapassaria:
                    motivos.append(f"OTPM: {uso['otpm_atual']+tokens_output_est:,}/{self.limite_otpm:,}")
                
                return True, tempo_espera, ", ".join(motivos)
            
            return True, 5, "Preventivo"
        
        return False, 0, None
    
    def aguardar_se_necessario(self, tokens_input_estimados: int = None, tokens_output_estimados: int = None):
        """Espera se necessário"""
        precisa, segundos, motivo = self.precisa_esperar(tokens_input_estimados, tokens_output_estimados)
        
        if precisa:
            uso = self.calcular_uso_atual()
            print(f"\n⏳ Aguardando {segundos}s para respeitar rate limit", flush=True)
            print(f"   Motivo: {motivo}", flush=True)
            print(f"   Uso atual: ITPM {uso['itpm_percent']:.1f}% | OTPM {uso['otpm_percent']:.1f}% | RPM {uso['rpm_percent']:.1f}%", flush=True)
            time.sleep(segundos)
            self.total_esperas += 1
            self.tempo_total_espera += segundos
    
    def exibir_status(self):
        """Mostra status atual"""
        uso = self.calcular_uso_atual()
        
        def barra(percent):
            largura = 20
            preenchido = int((min(percent, 100) / 100) * largura)
            barra_str = "█" * preenchido + "░" * (largura - preenchido)
            
            if percent > 95:
                cor = "🔴"
            elif percent > 85:
                cor = "🟡"
            else:
                cor = "🟢"
            
            return f"{cor} {barra_str} {min(percent, 100):.1f}%"
        
        print(f"\n📊 STATUS DO RATE LIMIT:", flush=True)
        print(f"   ITPM: {barra(uso['itpm_percent'])} ({uso['itpm_atual']:,}/{self.limite_itpm:,})", flush=True)
        print(f"   OTPM: {barra(uso['otpm_percent'])} ({uso['otpm_atual']:,}/{self.limite_otpm:,})", flush=True)
        print(f"   RPM:  {barra(uso['rpm_percent'])} ({uso['rpm_atual']}/{self.limite_rpm})", flush=True)
    
    def obter_estatisticas(self):
        """Retorna estatísticas gerais"""
        return {
            "total_requisicoes": self.total_requisicoes,
            "total_tokens": self.total_tokens,
            "total_esperas": self.total_esperas,
            "tempo_total_espera": self.tempo_total_espera,
            "media_tokens_req": self.total_tokens / max(1, self.total_requisicoes),
        }


# ============================================================================
# SISTEMA DE PLANEJAMENTO AVANÇADO
# ============================================================================

class PlanificadorAvancado:
    """
    Sistema de planejamento em 3 fases:
    1. ANÁLISE: Entende a tarefa profundamente (~30k tokens)
    2. ESTRATÉGIA: Cria plano otimizado (~20k tokens)
    3. DECOMPOSIÇÃO: Divide em subtarefas paralelas (~15k tokens)
    """
    
    def __init__(self, agente):
        self.agente = agente
        self.historico_planos = []
        self.metricas = {
            'planos_criados': 0,
            'taxa_sucesso': 0,
            'tempo_medio_economizado': 0
        }
    
    def planejar(self, tarefa: str, contexto: dict = None) -> Plano:
        """Cria um plano detalhado de execução"""
        print("\n🧠 SISTEMA DE PLANEJAMENTO ATIVADO")
        print("="*70)
        
        # Fase 1: ANÁLISE PROFUNDA (~30k tokens)
        print("\n📊 FASE 1: Análise Profunda da Tarefa...", flush=True)
        analise = self._analisar_tarefa(tarefa, contexto)
        
        # Fase 2: ESTRATÉGIA (~20k tokens)
        print("\n🎯 FASE 2: Criação de Estratégia Otimizada...", flush=True)
        estrategia = self._criar_estrategia(tarefa, analise)
        
        # Fase 3: DECOMPOSIÇÃO (~15k tokens)
        print("\n📋 FASE 3: Decomposição em Subtarefas...", flush=True)
        decomposicao = self._decompor_em_subtarefas(estrategia)
        
        # Criar ondas de execução
        ondas = self._criar_ondas(decomposicao)
        
        # Criar objeto Plano
        plano = Plano(
            tarefa_original=tarefa,
            analise=analise,
            estrategia=estrategia,
            decomposicao=decomposicao,
            ondas=ondas,
            criado_em=datetime.now()
        )
        
        self.historico_planos.append(plano)
        self.metricas['planos_criados'] += 1
        
        print(f"\n✅ PLANO CRIADO!")
        print(f"   Subtarefas: {len([st for onda in ondas for st in onda.subtarefas])}")
        print(f"   Ondas de execução: {len(ondas)}")
        
        return plano
    
    def _analisar_tarefa(self, tarefa: str, contexto: dict) -> dict:
        """Fase 1: Análise profunda da tarefa"""
        prompt = f"""ANÁLISE PROFUNDA DA TAREFA

Tarefa solicitada:
{tarefa}

Contexto adicional:
{json.dumps(contexto, indent=2) if contexto else 'Nenhum'}

Faça uma análise EXTREMAMENTE detalhada e retorne JSON:

{{
    "requisitos_explicitos": ["lista de requisitos mencionados diretamente"],
    "requisitos_implicitos": ["lista de requisitos não mencionados mas necessários"],
    "dependencias": {{
        "ferramentas": ["lista de ferramentas necessárias"],
        "bibliotecas": ["lista de bibliotecas Python necessárias"],
        "arquivos": ["lista de arquivos necessários"]
    }},
    "riscos": [
        {{"descricao": "...", "probabilidade": "alta/media/baixa", "impacto": "alto/medio/baixo"}}
    ],
    "estimativa_complexidade": "simples/media/complexa/muito_complexa",
    "tempo_estimado": "tempo estimado total",
    "conhecimento_previo_relevante": ["aprendizados relevantes"]
}}

Responda APENAS com o JSON, sem texto adicional."""

        resultado = self.agente._executar_requisicao_simples(prompt, max_tokens=4096)
        
        try:
            # Limpar markdown se houver
            resultado_limpo = resultado.strip()
            if resultado_limpo.startswith("```json"):
                resultado_limpo = resultado_limpo[7:]
            if resultado_limpo.endswith("```"):
                resultado_limpo = resultado_limpo[:-3]
            
            return json.loads(resultado_limpo.strip())
        except:
            return {
                "requisitos_explicitos": [tarefa],
                "requisitos_implicitos": [],
                "dependencias": {"ferramentas": [], "bibliotecas": [], "arquivos": []},
                "riscos": [],
                "estimativa_complexidade": "media",
                "tempo_estimado": "desconhecido"
            }
    
    def _criar_estrategia(self, tarefa: str, analise: dict) -> dict:
        """Fase 2: Criação de estratégia otimizada"""
        prompt = f"""CRIAÇÃO DE ESTRATÉGIA OTIMIZADA

Tarefa original:
{tarefa}

Análise realizada:
{json.dumps(analise, indent=2)}

Crie a melhor estratégia de execução e retorne JSON:

{{
    "abordagem": "descrição da abordagem principal",
    "justificativa": "por que esta abordagem é a melhor",
    "sequencia_otima": [
        {{"ordem": 1, "acao": "descrição da ação", "razao": "por que fazer primeiro"}}
    ],
    "oportunidades_paralelizacao": [
        {{"acoes": ["acao1", "acao2"], "ganho_estimado": "estimativa de ganho"}}
    ],
    "pontos_validacao": [
        {{"apos": "qual ação", "validar": "o que validar", "criterio_sucesso": "como saber que está certo"}}
    ],
    "planos_contingencia": ["plano B caso algo falhe"]
}}

Responda APENAS com o JSON, sem texto adicional."""

        resultado = self.agente._executar_requisicao_simples(prompt, max_tokens=4096)
        
        try:
            resultado_limpo = resultado.strip()
            if resultado_limpo.startswith("```json"):
                resultado_limpo = resultado_limpo[7:]
            if resultado_limpo.endswith("```"):
                resultado_limpo = resultado_limpo[:-3]
            
            return json.loads(resultado_limpo.strip())
        except:
            return {
                "abordagem": "execução direta",
                "justificativa": "abordagem simples",
                "sequencia_otima": [],
                "oportunidades_paralelizacao": [],
                "pontos_validacao": []
            }
    
    def _decompor_em_subtarefas(self, estrategia: dict) -> dict:
        """Fase 3: Decomposição em subtarefas executáveis"""
        prompt = f"""DECOMPOSIÇÃO EM SUBTAREFAS EXECUTÁVEIS

Estratégia definida:
{json.dumps(estrategia, indent=2)}

Decomponha em subtarefas CONCRETAS e EXECUTÁVEIS. Retorne JSON:

{{
    "ondas": [
        {{
            "numero": 1,
            "descricao": "descrição da onda",
            "subtarefas": [
                {{
                    "id": "1.1",
                    "titulo": "título curto",
                    "descricao": "descrição detalhada",
                    "ferramentas": ["lista de ferramentas"],
                    "input": "input esperado",
                    "output_esperado": "output esperado",
                    "criterio_sucesso": "como validar",
                    "tokens_estimados": 5000,
                    "tempo_estimado": "30s",
                    "prioridade": "critica",
                    "dependencias": []
                }}
            ],
            "pode_executar_paralelo": true
        }}
    ],
    "total_subtarefas": 0,
    "tempo_estimado_sequencial": "tempo",
    "tempo_estimado_paralelo": "tempo"
}}

Responda APENAS com o JSON, sem texto adicional."""

        resultado = self.agente._executar_requisicao_simples(prompt, max_tokens=4096)
        
        try:
            resultado_limpo = resultado.strip()
            if resultado_limpo.startswith("```json"):
                resultado_limpo = resultado_limpo[7:]
            if resultado_limpo.endswith("```"):
                resultado_limpo = resultado_limpo[:-3]
            
            decomp = json.loads(resultado_limpo.strip())
            # Atualizar total
            decomp['total_subtarefas'] = sum(len(onda.get('subtarefas', [])) for onda in decomp.get('ondas', []))
            return decomp
        except Exception as e:
            print(f"   ⚠️  Erro ao parsear decomposição: {e}")
            return {
                "ondas": [],
                "total_subtarefas": 0,
                "tempo_estimado_sequencial": "desconhecido",
                "tempo_estimado_paralelo": "desconhecido"
            }
    
    def _criar_ondas(self, decomposicao: dict) -> List[Onda]:
        """Cria objetos Onda a partir da decomposição"""
        ondas = []
        
        for onda_dict in decomposicao.get('ondas', []):
            subtarefas = []
            
            for st_dict in onda_dict.get('subtarefas', []):
                subtarefa = Subtarefa(
                    id=st_dict.get('id', ''),
                    titulo=st_dict.get('titulo', ''),
                    descricao=st_dict.get('descricao', ''),
                    ferramentas=st_dict.get('ferramentas', []),
                    input_esperado=st_dict.get('input', ''),
                    output_esperado=st_dict.get('output_esperado', ''),
                    criterio_sucesso=st_dict.get('criterio_sucesso', ''),
                    tokens_estimados=st_dict.get('tokens_estimados', 5000),
                    tempo_estimado=st_dict.get('tempo_estimado', '30s'),
                    prioridade=st_dict.get('prioridade', 'importante'),
                    dependencias=st_dict.get('dependencias', [])
                )
                subtarefas.append(subtarefa)
            
            onda = Onda(
                numero=onda_dict.get('numero', 0),
                descricao=onda_dict.get('descricao', ''),
                subtarefas=subtarefas,
                pode_executar_paralelo=onda_dict.get('pode_executar_paralelo', False)
            )
            ondas.append(onda)
        
        return ondas
    
    def executar_plano(self, plano: Plano) -> dict:
        """Executa o plano criado"""
        print("\n🚀 EXECUTANDO PLANO...")
        print("="*70)
        
        resultados = {}
        falhas = []
        
        for onda in plano.ondas:
            print(f"\n🌊 ONDA {onda.numero}: {onda.descricao}")
            print(f"   Subtarefas: {len(onda.subtarefas)}")
            print(f"   Paralelo: {'✅' if onda.pode_executar_paralelo else '❌'}")
            
            if onda.pode_executar_paralelo and len(onda.subtarefas) > 1:
                # Usar processador paralelo
                if hasattr(self.agente, 'processador_paralelo'):
                    resultados_onda = self.agente.processador_paralelo._processar_ondas_paralelas([onda])
                else:
                    # Fallback: execução sequencial
                    resultados_onda = self._executar_onda_sequencial(onda)
            else:
                resultados_onda = self._executar_onda_sequencial(onda)
            
            # Processar resultados
            for subtarefa_id, resultado in resultados_onda.items():
                if resultado.get('sucesso'):
                    resultados[subtarefa_id] = resultado
                    print(f"   ✅ {subtarefa_id}: Concluída")
                else:
                    falhas.append({
                        'subtarefa_id': subtarefa_id,
                        'erro': resultado.get('erro'),
                        'onda': onda.numero
                    })
                    print(f"   ❌ {subtarefa_id}: Falhou - {resultado.get('erro', 'erro desconhecido')}")
        
        resultado_final = {
            'sucesso': len(falhas) == 0,
            'total_subtarefas': sum(len(o.subtarefas) for o in plano.ondas),
            'concluidas': len(resultados),
            'falhas': len(falhas),
            'resultados': resultados,
            'detalhes_falhas': falhas
        }
        
        print("\n" + "="*70)
        if resultado_final['sucesso']:
            print("🎉 PLANO EXECUTADO COM SUCESSO!")
        else:
            print(f"⚠️  PLANO PARCIALMENTE EXECUTADO ({resultado_final['concluidas']}/{resultado_final['total_subtarefas']})")
        
        return resultado_final
    
    def _executar_onda_sequencial(self, onda: Onda) -> dict:
        """Executa ondas sequencialmente"""
        resultados = {}
        
        for st in onda.subtarefas:
            try:
                prompt = f"""SUBTAREFA {st.id}: {st.titulo}

DESCRIÇÃO:
{st.descricao}

INPUT:
{st.input_esperado}

OUTPUT ESPERADO:
{st.output_esperado}

CRITÉRIO DE SUCESSO:
{st.criterio_sucesso}

Execute esta subtarefa de forma completa e precisa."""
                
                resultado_texto = self.agente._executar_requisicao_simples(prompt, max_tokens=2048)
                
                resultados[st.id] = {
                    'sucesso': True,
                    'output': resultado_texto
                }
            except Exception as e:
                resultados[st.id] = {
                    'sucesso': False,
                    'erro': str(e)
                }
        
        return resultados


# ============================================================================
# PROCESSADOR PARALELO AGRESSIVO
# ============================================================================

class ProcessadorParalelo:
    """Executa múltiplas tarefas simultaneamente (Tier 2: 15-20 workers)"""
    
    def __init__(self, agente, max_workers: int = 15):
        self.agente = agente
        self.max_workers = max_workers
        self.semaphore = threading.Semaphore(max_workers)
        self.estatisticas = {
            'tarefas_processadas': 0,
            'tempo_total_economizado': 0
        }
    
    def processar_lista(self, tarefas: List[str]) -> List[str]:
        """Processa lista de tarefas em paralelo"""
        print(f"\n🚀 PROCESSAMENTO PARALELO INICIADO")
        print(f"   Total tarefas: {len(tarefas)}")
        print(f"   Workers: {self.max_workers}")
        print("="*70)
        
        inicio = time.time()
        resultados = []
        
        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            futures = {
                executor.submit(self._processar_tarefa, tarefa): i
                for i, tarefa in enumerate(tarefas)
            }
            
            for future in as_completed(futures):
                idx = futures[future]
                try:
                    resultado = future.result()
                    resultados.append((idx, resultado))
                    print(f"   ✅ Tarefa {idx+1}/{len(tarefas)} concluída")
                except Exception as e:
                    print(f"   ❌ Tarefa {idx+1}/{len(tarefas)} falhou: {e}")
                    resultados.append((idx, {'erro': str(e)}))
        
        # Ordenar por índice original
        resultados.sort(key=lambda x: x[0])
        resultados = [r[1] for r in resultados]
        
        tempo_total = time.time() - inicio
        tempo_sequencial_estimado = len(tarefas) * 30
        tempo_economizado = tempo_sequencial_estimado - tempo_total
        
        self.estatisticas['tarefas_processadas'] += len(tarefas)
        self.estatisticas['tempo_total_economizado'] += tempo_economizado
        
        print(f"\n✅ PROCESSAMENTO PARALELO CONCLUÍDO!")
        print(f"   Tempo: {tempo_total:.1f}s")
        print(f"   Tempo economizado: {tempo_economizado:.1f}s")
        print(f"   Speedup: {tempo_sequencial_estimado/tempo_total:.1f}x")
        
        return resultados
    
    def _processar_tarefa(self, tarefa: str) -> str:
        """Processa uma tarefa individual"""
        with self.semaphore:
            return self.agente._executar_requisicao_simples(tarefa, max_tokens=2048)
    
    def _processar_ondas_paralelas(self, ondas: List[Onda]) -> dict:
        """Processa ondas de subtarefas em paralelo"""
        resultados = {}
        
        for onda in ondas:
            if onda.pode_executar_paralelo and len(onda.subtarefas) > 1:
                with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
                    futures = {
                        executor.submit(self._executar_subtarefa, st): st.id
                        for st in onda.subtarefas
                    }
                    
                    for future in as_completed(futures):
                        subtarefa_id = futures[future]
                        try:
                            resultado = future.result()
                            resultados[subtarefa_id] = resultado
                        except Exception as e:
                            resultados[subtarefa_id] = {
                                'sucesso': False,
                                'erro': str(e)
                            }
            else:
                # Execução sequencial
                for st in onda.subtarefas:
                    resultados[st.id] = self._executar_subtarefa(st)
        
        return resultados
    
    def _executar_subtarefa(self, subtarefa: Subtarefa) -> dict:
        """Executa uma subtarefa"""
        try:
            prompt = f"""SUBTAREFA {subtarefa.id}: {subtarefa.titulo}

{subtarefa.descricao}

Execute de forma completa e precisa."""
            
            resultado = self.agente._executar_requisicao_simples(prompt, max_tokens=2048)
            
            return {
                'sucesso': True,
                'output': resultado
            }
        except Exception as e:
            return {
                'sucesso': False,
                'erro': str(e)
            }


# ============================================================================
# SISTEMA DE FERRAMENTAS (PLACEHOLDER - USAR CÓDIGO COMPLETO ORIGINAL)
# ============================================================================

class SistemaFerramentasCompleto:
    """Sistema de ferramentas simplificado para demonstração"""
    
    def __init__(self, master_password: str = None, usar_memoria: bool = True):
        self.ferramentas_descricao = []
        self.ferramentas_codigo = {}
        self.browser = None
        self.page = None
        
        # Carregar ferramentas básicas
        self._carregar_ferramentas_base()
    
    def _carregar_ferramentas_base(self):
        """Carregar ferramentas básicas (bash, arquivos, etc)"""
        # Adicionar ferramentas básicas aqui
        # (usar código completo do arquivo original)
        pass
    
    def adicionar_ferramenta(self, nome: str, codigo: str, descricao: str, parametros: dict):
        """Adiciona ferramenta"""
        self.ferramentas_codigo[nome] = codigo
        
        self.ferramentas_descricao.append({
            "name": nome,
            "description": descricao,
            "input_schema": {
                "type": "object",
                "properties": parametros,
                "required": list(parametros.keys()) if parametros else []
            }
        })
    
    def executar(self, nome: str, parametros: dict) -> str:
        """Executa ferramenta"""
        if nome not in self.ferramentas_codigo:
            return f"ERRO: Ferramenta '{nome}' não existe"
        
        # Executar código da ferramenta
        try:
            namespace = {'__builtins__': __builtins__}
            exec(self.ferramentas_codigo[nome], namespace)
            
            func = namespace.get(nome)
            if func:
                return str(func(**parametros))
            
            return "ERRO: Função não encontrada"
        except Exception as e:
            return f"ERRO: {e}"
    
    def obter_descricoes(self) -> list:
        """Retorna descrições das ferramentas"""
        return self.ferramentas_descricao


# ============================================================================
# AGENTE COMPLETO COM TODAS AS FUNCIONALIDADES
# ============================================================================

class AgenteComTier2Completo:
    """Agente com Tier 2, Planejamento Avançado e Processamento Paralelo"""
    
    def __init__(
        self, 
        api_key: str, 
        master_password: str = None, 
        usar_memoria: bool = True,
        tier: str = "tier2",
        modo_rate_limit: str = "agressivo",
        usar_planejamento: bool = True,
        usar_paralelismo: bool = True
    ):
        self.client = anthropic.Anthropic(api_key=api_key)
        self.sistema_ferramentas = SistemaFerramentasCompleto(master_password, usar_memoria)
        self.historico_conversa = []
        self.max_iteracoes_atual = 40
        
        # Rate limit manager com modo configurável
        self.rate_limit_manager = RateLimitManager(tier=tier, modo=modo_rate_limit)
        
        # Sistema de planejamento
        self.usar_planejamento = usar_planejamento
        self.planificador = PlanificadorAvancado(self) if usar_planejamento else None
        
        # Sistema de paralelismo
        self.usar_paralelismo = usar_paralelismo
        # Tier 2: 15-20 workers
        max_workers = 15 if tier == "tier2" else (20 if tier in ["tier3", "tier4"] else 5)
        self.processador_paralelo = ProcessadorParalelo(self, max_workers=max_workers) if usar_paralelismo else None
        
        # Sistema de recuperação de erros
        self.modo_recuperacao = False
        self.erros_recentes = []
    
    def _executar_requisicao_simples(self, prompt: str, max_tokens: int = 4096) -> str:
        """Executa uma requisição simples à API"""
        self.rate_limit_manager.aguardar_se_necessario()
        
        try:
            response = self.client.messages.create(
                model="claude-sonnet-4-5-20250929",
                max_tokens=max_tokens,
                messages=[{"role": "user", "content": prompt}]
            )
            
            # Registrar uso
            tokens_input = response.usage.input_tokens
            tokens_output = response.usage.output_tokens
            self.rate_limit_manager.registrar_uso(tokens_input, tokens_output)
            
            # Extrair texto
            texto = ""
            for block in response.content:
                if hasattr(block, "text"):
                    texto += block.text
            
            return texto
            
        except RateLimitError as e:
            print(f"\n⚠️  RATE LIMIT ATINGIDO! Aguardando 60s...")
            time.sleep(60)
            return self._executar_requisicao_simples(prompt, max_tokens)
        except Exception as e:
            return f"ERRO: {e}"
    
    def _tarefa_e_complexa(self, tarefa: str) -> bool:
        """Detecta se tarefa é complexa o suficiente para planejamento"""
        indicadores_complexidade = [
            'criar', 'desenvolver', 'implementar', 'sistema', 'completo',
            'api', 'aplicação', 'projeto', 'arquitetura', 'integrar',
            'múltiplos', 'vários', 'todos', 'completo', 'end-to-end'
        ]
        
        tarefa_lower = tarefa.lower()
        matches = sum(1 for ind in indicadores_complexidade if ind in tarefa_lower)
        
        return matches >= 2 or len(tarefa) > 200
    
    def executar_tarefa(self, tarefa: str, max_iteracoes: int = None, usar_planejamento_forcado: bool = None):
        """Executa tarefa com planejamento e paralelismo"""
        
        if max_iteracoes is None:
            max_iteracoes = self.max_iteracoes_atual
        
        print("\n" + "="*70)
        print(f"🎯 TAREFA: {tarefa}")
        print("="*70)
        
        # Decidir se usa planejamento
        usar_plan = usar_planejamento_forcado if usar_planejamento_forcado is not None else (
            self.usar_planejamento and self._tarefa_e_complexa(tarefa)
        )
        
        if usar_plan and self.planificador:
            print("\n🧠 Tarefa complexa detectada. Ativando sistema de planejamento...")
            
            # Criar plano
            plano = self.planificador.planejar(tarefa)
            
            # Salvar plano
            plano_path = f"Luna/planos/plano_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
            plano.salvar(plano_path)
            print(f"   💾 Plano salvo em: {plano_path}")
            
            # Executar plano
            resultado = self.planificador.executar_plano(plano)
            
            return resultado
        else:
            # Execução normal (sem planejamento)
            print("\n⚡ Execução direta (sem planejamento)")
            resultado = self._executar_requisicao_simples(tarefa, max_tokens=4096)
            
            print("\n" + "="*70)
            print("✅ CONCLUÍDO!")
            print("="*70)
            print(resultado)
            
            return resultado


# ============================================================================
# INTERFACE PRINCIPAL
# ============================================================================

def main():
    print("""
════════════════════════════════════════════════════════════════════════════════

  🌙 LUNA V3 - TIER 2 COMPLETO + PLANEJAMENTO + PARALELISMO

  ✅ Limites corretos (1000 RPM, 450K ITPM, 90K OTPM)
  🧠 Sistema de Planejamento Avançado
  🔄 Processamento Paralelo (15-20 tarefas simultâneas)
  🛡️ Rate Limiting Inteligente
  🛑 Handler de Interrupção (Ctrl+C)

════════════════════════════════════════════════════════════════════════════════
    """)
    
    # ✅ CORREÇÃO CRÍTICA: Carregar variáveis de ambiente do .env
    load_dotenv()
    
    api_key = os.getenv('ANTHROPIC_API_KEY')
    if not api_key:
        print("❌ Configure ANTHROPIC_API_KEY no .env")
        return
    
    # Configurar tier
    print("\n🛡️  CONFIGURAÇÃO")
    print("   Qual é o seu tier da API Anthropic?")
    print("   1. Tier 1 (50 RPM, 30K ITPM, 8K OTPM)")
    print("   2. Tier 2 (1000 RPM, 450K ITPM, 90K OTPM) ← RECOMENDADO")
    print("   3. Tier 3 (2000 RPM, 800K ITPM, 160K OTPM)")
    print("   4. Tier 4 (4000 RPM, 2M ITPM, 400K OTPM)")
    
    tier_input = input("\n   Escolha (1-4, Enter=2): ").strip()
    tier_map = {"1": "tier1", "2": "tier2", "3": "tier3", "4": "tier4", "": "tier2"}
    tier = tier_map.get(tier_input, "tier2")
    
    # Configurar modo
    print("\n   Modo de rate limiting:")
    print("   1. Conservador (75% threshold)")
    print("   2. Balanceado (85% threshold)")
    print("   3. Agressivo (95% threshold) ← RECOMENDADO para Tier 2+")
    
    modo_input = input("\n   Escolha (1-3, Enter=3): ").strip()
    modo_map = {"1": "conservador", "2": "balanceado", "3": "agressivo", "": "agressivo"}
    modo = modo_map.get(modo_input, "agressivo")
    
    # Criar agente
    try:
        agente = AgenteComTier2Completo(
            api_key, 
            tier=tier,
            modo_rate_limit=modo,
            usar_planejamento=True,
            usar_paralelismo=True
        )
    except Exception as e:
        print(f"\n❌ Erro ao criar agente: {e}")
        return
    
    # Criar handler de interrupção
    handler = InterruptHandler(agente=agente, sistema_ferramentas=agente.sistema_ferramentas)
    
    print("\n✅ Luna V3 iniciada!")
    print("   🧠 Sistema de Planejamento: ATIVADO")
    print("   🔄 Processamento Paralelo: ATIVADO")
    print(f"   🛡️  Rate Limit: {tier.upper()} - {modo.upper()}")
    
    print("\n💡 DICA: Para tarefas complexas, a Luna criará um plano detalhado antes de executar!")
    print("🛑 DICA: Pressione Ctrl+C para interromper graciosamente")
    
    # Loop principal
    while True:
        try:
            print("\n" + "─"*70)
            comando = input("\n💬 O que você quer? (ou 'sair'): ").strip()
            
            if comando.lower() in ['sair', 'exit', 'quit', '']:
                print("\n👋 Até logo!")
                
                # Estatísticas finais
                print("\n📊 ESTATÍSTICAS FINAIS:")
                stats = agente.rate_limit_manager.obter_estatisticas()
                print(f"   Requisições: {stats['total_requisicoes']}")
                print(f"   Tokens: {stats['total_tokens']:,}")
                print(f"   Média tokens/req: {stats['media_tokens_req']:.0f}")
                if stats['total_esperas'] > 0:
                    print(f"   Esperas: {stats['total_esperas']} ({stats['tempo_total_espera']:.0f}s total)")
                
                if agente.planificador:
                    print(f"\n   🧠 Planos criados: {agente.planificador.metricas['planos_criados']}")
                
                if agente.processador_paralelo:
                    print(f"   🔄 Tarefas paralelas: {agente.processador_paralelo.estatisticas['tarefas_processadas']}")
                
                break
            
            # Executar tarefa
            agente.executar_tarefa(comando)
            input("\n⏸️  Pressione ENTER para continuar...")
            
        except KeyboardInterrupt:
            break
        except Exception as e:
            print(f"\n❌ Erro inesperado: {e}")
            import traceback
            traceback.print_exc()


if __name__ == "__main__":
    main()
